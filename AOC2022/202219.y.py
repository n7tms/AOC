# AOC 2022 - Day 19
# @Lucews
# https://topaz.github.io/paste/#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



import collections
import time
from heapq import heappop, heappush


def read_input(path: str = 'AOC2022/inputs/202219.txt'):
    inputs = []
    with open(path) as filet:
        for idx, line in enumerate(filet.readlines()):

            # read the line
            line = line.rstrip()

            # divide into instructions and blueprint number
            line = line.split(': ')

            # get and check the blueprint number
            blueprint = int(line[0].split(' ')[-1])
            assert blueprint == idx + 1, 'Blueprint number is not as expected.'

            # get the robot costs
            robots = line[1].split('. ')

            robot_materials = []
            # go through each of them and check whether they are as expected
            for idx, robot in enumerate(robots):

                # split the line further
                robot = robot.split(' ')

                # check for expected stuff
                if robot[1] == 'ore':

                    # check that it is the first robot
                    assert idx == 0, 'The ore robot is not the first.'

                    # check that it requires ore
                    assert robot[5] == 'ore', 'The ore robot is not as expected.'

                    # make the materials tuple
                    robot_materials.append((int(robot[4]), 0, 0, 0))

                elif robot[1] == 'clay':

                    # check that it is the first robot
                    assert idx == 1, 'The clay robot is not the second.'

                    # check that it requires ore
                    assert robot[5] == 'ore', 'The clay robot is not as expected.'

                    # make the materials tuple
                    robot_materials.append((int(robot[4]), 0, 0, 0))

                elif robot[1] == 'obsidian':

                    # check that it is the first robot
                    assert idx == 2, 'The obsidian robot is not the third.'

                    # check that it requires ore
                    assert robot[5] == 'ore' and robot[8] == 'clay', 'The obsidian robot is not as expected.'

                    # make the materials tuple
                    robot_materials.append((int(robot[4]), int(robot[7]), 0, 0))

                elif robot[1] == 'geode':

                    # check that it is the first robot
                    assert idx == 3, 'The geode robot is not the fourth.'

                    # check that it requires ore
                    assert robot[5] == 'ore' and robot[8] == 'obsidian.', 'The geode robot is not as expected.'

                    # make the materials tuple
                    robot_materials.append((int(robot[4]), 0, int(robot[7]), 0))
            inputs.append(robot_materials)
    return inputs


def optimize_factory(costs: list[tuple[int, int, int, int]], time_horizon: int, debug=False) -> tuple[int, int]:
    # first idea is to build some kind of simulation for a factory on how many geodes we can break with it.
    #
    # I think a simulation per minute is appropriate. We could do this using BFS, so we have everything in a loop.
    # Our target is the amount of geodes we can crack.
    #
    # Maybe we should do some kind of topological sort in order to keep track of which robots we can build?
    #
    # Other than that we need to keep track of:
    #
    # 1) Which Materials we have after n minutes
    # 2) How many Materials we produce every minute
    # 3) Which robots we can build with this
    # 4) How many geodes we cracked

    # 1) and 2) from above will be our search space, as we can construct different robots and any minute
    # 3) is a function that tells us which paths we can go
    # 4) is the thing we want to maximize and also keep track of

    # get the maximum amount of materials used for any robot, so we don't make more robots than this cost
    # as we would not be able to get rid of it
    max_materials_necessary = [max(cost[idx] for cost in costs) for idx in range(len(costs))]
    max_materials_necessary[3] = float('inf')  # we need as many geodes opened as possible

    # initialize the bfs with some kind of queue that consists of tuples
    # (time_left, materials(ore, clay, obsidian, geodes), robots(ore, clay, obsidian, geodes))
    queue = collections.deque([(time_horizon, (0, 0, 0, 0), (1, 0, 0, 0))])
    # the order of things happening will be:
    #
    # a) keep track of maximum geodes
    # b) check which robots we can build
    # c) for every path update the materials
    # d) for every path append (build) the robots and updated materials to the queue
    result = 0
    counter = 0
    start_time = time.time()
    state_cache = collections.defaultdict(lambda: -1)
    while queue:

        # pop from the queue (from the rightmost as this might be the ones having geode robots, as I append these
        # last!)
        time_left, materials, robots = queue.pop()

        # increase the counter
        counter += 1
        if counter % 500_000 == 0 and debug:
            print(time_left, materials, robots, len(queue))
            print(f'{counter / 1_000_000:0.1f} M. Result: {result}. Elapsed time: {time.time() - start_time} s.')
            print()

        # keep track of maximum geodes
        result = max(result, materials[3])

        # think about whether we can reach the goal if we produce a geode roboter in every step now (upper bound) ------
        upper_bound_geodes = ((time_left + robots[3]) * (time_left + robots[3] + 1)) // 2 \
                             - (robots[3] * (robots[3] + 1)) // 2 \
                             + materials[3]
        if upper_bound_geodes <= result:
            continue

        # update the cache and see whether we already found a better path ----------------------------------------------
        # make and update the cache (for the cache it does not matter how much geode a state has
        # only how much it can produce as no one can use the geode to make any more robots)
        key = (time_left, materials[:3], robots)
        if state_cache[key] >= materials[3]:
            continue
        else:
            state_cache[key] = materials[3]

        # check whether our time is up
        if not time_left:
            continue

        # now think about whether it is useful to wait for any materials -----------------------------------------------

        # check whether we wait for any robot because we do not have the material yet
        # also: we only need to wait for that material if we have a robot for it, otherwise this specific material
        # will not be growing even if we wait for it
        should_wait = any(material < max_material and robot
                          for material, max_material, robot in zip(materials, max_materials_necessary, robots))

        # if we are still shure we should wait, then we append a waiting state
        if should_wait:
            new_materials = tuple(material + robot for material, robot in zip(materials, robots))
            new_robots = robots[:]

            # append to the queue
            queue.append((time_left - 1, new_materials, new_robots))

        # build the robots ---------------------------------------------------------------------------------------------
        for idx, cost in enumerate(costs):

            # only build a robot if:
            #
            # a) We need more of that robot as we do not produce enough material every step to produce any robot
            # b) We have all the material we need for that robot
            if max_materials_necessary[idx] > robots[idx] \
                    and all(material >= prize for material, prize in zip(materials, cost)):
                # update the materials we will have in the next step
                new_materials = tuple(
                    material + robot - prize for material, robot, prize in zip(materials, robots, cost))

                # update the robots we will have
                new_robots = tuple(robot + 1 if rx == idx else robot for rx, robot in enumerate(robots))

                # append to the queue
                queue.append((time_left - 1, new_materials, new_robots))
    return result, counter


def optimize_factory_heaped(costs: list[tuple[int, int, int, int]], time_horizon: int, debug=False) -> tuple[int, int]:
    # get maximum necessary materials
    max_materials_necessary = [max(cost[idx] for cost in costs) for idx in range(len(costs))]
    max_materials_necessary[3] = float('inf')  # we need as many geodes opened as possible

    # initialize the heap with tuples
    # (geode_robots, time_left, materials(ore, clay, obsidian, geodes), robots(ore, clay, obsidian, geodes))
    queue = [(0, time_horizon, (0, 0, 0, 0), (1, 0, 0, 0))]

    # go through the queue
    result = 0
    counter = 0
    start_time = time.time()
    state_cache = collections.defaultdict(lambda: -1)
    while queue:

        # pop from the queue
        _, time_left, materials, robots = heappop(queue)

        # increase the counter
        counter += 1
        if counter % 500_000 == 0 and debug:
            print(time_left, materials, robots, len(queue))
            print(f'{counter / 1_000_000:0.1f} M. Result: {result}. Elapsed time: {time.time() - start_time} s.')
            print()

        # keep track of maximum geodes we can make with this current state (also incorporate the future)
        result = max(result, materials[3] + robots[3]*time_left)

        # think about whether we can reach the goal if we produce a geode roboter in every step now (upper bound) ------
        upper_bound_geodes = ((time_left + robots[3]) * (time_left + robots[3] + 1)) // 2 \
                             - (robots[3] * (robots[3] + 1)) // 2 \
                             + materials[3]
        if upper_bound_geodes <= result:
            continue

        # update the cache and see whether we already found a better path ----------------------------------------------
        # make and update the cache (for the cache it does not matter how much geode a state has
        # only how much it can produce as no one can use the geode to make any more robots)
        key = (time_left, materials[:3], robots)
        if state_cache[key] >= materials[3]:
            continue
        else:
            state_cache[key] = materials[3]

        # check whether our time is up
        if not time_left:
            continue

        # now think about whether it is useful to wait for any materials -----------------------------------------------

        # check whether we wait for any robot because we do not have the material yet
        # also: we only need to wait for that material if we have a robot for it, otherwise this specific material
        # will not be growing even if we wait for it
        should_wait = any(material < max_material and robot
                          for material, max_material, robot in zip(materials, max_materials_necessary, robots))

        # if we are still shure we should wait, then we append a waiting state
        if should_wait:
            new_materials = tuple(material + robot for material, robot in zip(materials, robots))
            new_robots = robots[:]

            # append to the queue
            queue.append((-new_robots[3], time_left - 1, new_materials, new_robots))

        # build the robots ---------------------------------------------------------------------------------------------
        for idx, cost in enumerate(costs):

            # check whether we want and should build the robot
            if max_materials_necessary[idx] > robots[idx] \
                    and all(material >= prize for material, prize in zip(materials, cost)):
                # update the materials we will have in the next step
                new_materials = tuple(
                    material + robot - prize for material, robot, prize in zip(materials, robots, cost))

                # update the robots we will have
                new_robots = tuple(robot + 1 if rx == idx else robot for rx, robot in enumerate(robots))

                # append to the queue
                queue.append((-new_robots[3], time_left - 1, new_materials, new_robots))
    return result, counter


def main1(time_horizon=24):

    # get the inputs (we now know how much each robot costs)
    inputs = read_input()

    # go through each factory (and time it)
    result = 0
    for idx, factory in enumerate(inputs, 1):
        start_time = time.time()
        # best_geodes, steps = optimize_factory(factory, time_horizon)
        best_geodes, steps = optimize_factory_heaped(factory, time_horizon)
        print(f'Factory {idx} for {time_horizon} minutes optimization took {time.time() - start_time: 0.2f} s '
              f'and {steps/1_000_000:0.3f} M steps.')
        result += best_geodes*idx

    print(f'The result for solution 1 is: {result}')


def main2(time_horizon=32):

    # get the inputs (we now know how much each robot costs)
    inputs = read_input()

    # go through each factory
    result = 1
    for idx, factory in enumerate(inputs[:3], 1):
        start_time = time.time()
        best_geodes, steps = optimize_factory_heaped(factory, time_horizon)
        print(f'Factory {idx} for {time_horizon} minutes optimization took {time.time() - start_time:0.2f} s '
              f'and {steps/1_000_000:0.3f} M steps.')
        result *= best_geodes

    print(f'The result for solution 2 is: {result}')


if __name__ == '__main__':
    main1()
    main2()
